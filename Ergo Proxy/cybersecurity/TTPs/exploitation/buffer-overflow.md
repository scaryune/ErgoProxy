
# Buffer Overflows:
In general, buffer overflows *target stack frames in [memory](computers/memory.md) allocated to data structures being used by a program.* The goal is to overwrite and *overflow* the stack frame in order to access memory not intended to be accessed by that frame.
## Vulnerability
Buffer overflows are possible when a program is able to write more data to the *buffer space* of a data structure/ subroutine than was intended. Writing past the bounds of the buffer causes *corruption of adjacent data on the call stack*. This will often cause the program to crash.

Additionally, stack memory *contains all the return addresses* for active function calls, so overflowing it *is more effective* at derailing an application than overflowing heap memory.
## Exploitation
Since the stack *stores all the return addresses* for functions on the call stack, the goal of most intentional buffer-overflows is to *overwrite the return address of a function w/ a pointer to malicious code instead* (which is also usually on the stack).
### Example
```c
#include <string.h>

void foo(char *bar)
{
   char c[12];

   strcpy(c, bar);  // no bounds checking
}

int main(int argc, char **argv)
{
   foo(argv[1]);
   return 0;
}
```
> [Wikipedia](https://en.wikipedia.org/wiki/Stack_buffer_overflow)

This [C](/coding/languages/c.md) code takes a command line argument and copies it to a variable called `c` *without checking how much space it will take up*. On execution *12 bytes of space* is allocated on the stack for the `c` variable. However in the C programming language *strings are terminated with a null byte* so really, if a string longer than 11 bytes is created, the 12 byte buffer will be overflowed:

![](/cybersecurity-pics/buffer-overflow-1.png)
![](cybersecurity/cybersecurity-pics/buffer-overflow-1.png)
> [Wikipedia](https://en.wikipedia.org/wiki/Stack_buffer_overflow)

On the call stack, just under the frame allocated for `c` is the next frame, allocated for `*bar` and under that frame *is the return address for the function `foo()`*. 

An attacker can overwrite data all the way down to the return address and then replace the data there *with a pointer to their own code*. Usually this pointer is *the address of the original variable* (in this case `c`). So when `foo()` returns, *the [CPU](computers/cpu.md)* pops the return address off the stack *and goes to that address* to continue executing code.
![](/cybersecurity-pics/buffer-overflow-2.png)
![](cybersecurity/cybersecurity-pics/buffer-overflow-2.png)
> [Wikipedia](https://en.wikipedia.org/wiki/Stack_buffer_overflow)

In this picture, The string of `AAAAA`'s represent the attacker-supplied data used for the overflow of `c`. Once an attacker *knows the amount of bytes it takes to reach and overwrite the return address*, they can replace part of their overflow string *with shellcode*. The CPU will return to the attacker-supplied address and begin executing the shellcode that's been inserted there. 

> [!Resources]
> - [Wikipedia: Buffer Overflows](https://en.wikipedia.org/wiki/Stack_buffer_overflow)